version: 2.1
description: |
  An orb for working with Amazon Elastic Container Service (ECS)
orbs:
  aws-cli: circleci/aws-cli@0.0.1

commands:
  wait-for-deployment-stability:
    parameters:
      family:
        description:
          "The family which will be used as a name for the task definition."
        type: string
      cluster-name:
        description:
          "The ECS cluster name"
        type: string
      task-definition-arn:
        description:
          "ARN of newly deployed task definition"
        type: string
      max-poll-attempts:
        description:
          "Maximum number of attempts to poll"
        type: string
        default: "50"
      poll-interval:
        description:
          "Polling interval"
        type: string
        default: "20"
      enable-trace:
        description:
          "Commands will be run with the xtrace shell option enabled (set -x).
           Do not enable this if you have sensitive variables that you do not
           want appearing in the build output."
        type: boolean
        default: false
    steps:
      - run:
          name: Wait for deployment to be stable
          command: |
            <<# parameters.enable-trace >> set -x <</ parameters.enable-trace >>
            attempt=0
            while [ "$attempt" -lt << parameters.max-poll-attempts >> ]
            do
                DEPLOYMENT_STATUS=$(aws ecs describe-services \
                    --cluster << parameters.cluster-name >> \
                    --services << parameters.family >> \
                    --output text \
                    --query 'services[0].deployments[].[taskDefinition, status]')
                NUM_DEPLOYMENTS=$(aws ecs describe-services \
                    --cluster << parameters.cluster-name >> \
                    --services << parameters.family >> \
                    --output text \
                    --query 'length(services[0].deployments)')
                TARGET_DEPLOYMENT_REVISION=$(aws ecs describe-services \
                    --cluster << parameters.cluster-name >> \
                    --services << parameters.family >> \
                    --output text \
                    --query "services[0].deployments[?taskDefinition==\`<< parameters.task-definition-arn >>\` && runningCount == desiredCount && (status == \`PRIMARY\` || status == \`ACTIVE\`)][taskDefinition]")
                echo "Current deployments: $DEPLOYMENT_STATUS"
                if [ "$NUM_DEPLOYMENTS" = "1" ] && [ "$TARGET_DEPLOYMENT_REVISION" = "$CCI_ORB_AWS_ECS_DEPLOYED_REVISION" ]; then
                    echo "Service updated: $DEPLOYED_REVISION"
                    exit 0
                else
                    echo "Waiting for stale deployments.."
                    sleep << parameters.poll-interval >>
                fi
                attempt=$((attempt + 1))
            done
            echo "Stopped waiting for deployment to be stable - please check the status of the deployment on the AWS ECS console"
            exit 1
  deploy-service-update:
    parameters:
      family:
        description:
          "The family which will be used as a name for the task definition."
        type: string
      cluster-name:
        description:
          "The ECS cluster name"
        type: string
      container-image-name-updates:
        description:
          "Images and tags to be updated in container definitions."
        type: string
        default: ""
      container-env-var-updates:
        description:
          "Environment variables to be updated in container definitions."
        type: string
        default: ""
      verify-revision-deployment-stable:
        description:
          "Verify that the revision has been deployed and is stable"
        type: boolean
        default: false
      enable-trace:
        description:
          "Commands will be run with the xtrace shell option enabled (set -x).
           Do not enable this if you have sensitive variables that you do not
           want appearing in the build output."
        type: boolean
        default: false
    steps:
      - run:
          name: Prepare new task definition
          command: |
            <<# parameters.enable-trace >> set -x <</ parameters.enable-trace >>
            PREVIOUS_TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition << parameters.family >>)
            CONTAINER_IMAGE_NAME_UPDATES="$(echo << parameters.container-image-name-updates >>)"
            CONTAINER_ENV_VAR_UPDATES="$(echo << parameters.container-env-var-updates >>)"

            # Prepare script for updating container definitions
            UPDATE_CONTAINER_DEFS_SCRIPT_FILE=$(mktemp _update_container_defs.py.XXXXXX)
            cat > $UPDATE_CONTAINER_DEFS_SCRIPT_FILE \<<-EOF
            from __future__ import absolute_import
            import sys
            import json
            
            
            def run(previous_task_definition, container_image_name_updates, container_env_var_updates):
                try:
                    definition = json.loads(previous_task_definition)
                    container_definitions = definition['taskDefinition']['containerDefinitions']
                except:
                    raise Exception('No valid task definition found: ' +
                                    previous_task_definition)
            
                # Build a map of the original container definitions so that the
                # array index positions can be easily looked up
                container_map = {}
                for index, container_definition in enumerate(container_definitions):
                    env_var_map = {}
                    env_var_definitions = container_definition.get('environment')
                    if env_var_definitions is not None:
                        for env_var_index, env_var_definition in enumerate(env_var_definitions):
                            env_var_map[env_var_definition['name']] = {
                                'index': env_var_index}
                    container_map[container_definition['name']] = {
                        'image': container_definition['image'], 'index': index, 'environment_map': env_var_map}
            
                # Expected format: container=...,name=...,value=...,container=...,name=...,value=
                try:
                    env_kv_pairs = container_env_var_updates.split(',')
                    for index, kv_pair in enumerate(env_kv_pairs):
                        kv = kv_pair.split('=')
                        key = kv[0].strip()
                        if key == 'container':
                            container_name = kv[1].strip()
                            env_var_name_kv = env_kv_pairs[index+1].split('=')
                            env_var_name = env_var_name_kv[1].strip()
                            env_var_value_kv = env_kv_pairs[index+2].split('=')
                            env_var_value = env_var_value_kv[1].strip()
                            if env_var_name_kv[0].strip() != 'name' or env_var_value_kv[0].strip() != 'value':
                                raise ValueError(
                                    'Environment variable update parameter format is incorrect: ' + container_env_var_updates)
            
                            container_entry = container_map.get(container_name)
                            if container_entry is None:
                                raise ValueError('The container ' + container_name +
                                                 ' is not defined in the existing task definition')
                            container_index = container_entry['index']
                            env_var_entry = container_entry['environment_map'].get(
                                env_var_name)
                            if env_var_entry is None:
                                raise ValueError('Environment variable ' + env_var_name +
                                                 ' is not defined for container ' + container_name + ' in the existing task definition')
                            env_var_index = env_var_entry['index']
                            container_definitions[container_index]['environment'][env_var_index]['value'] = env_var_value
                        elif key and key not in ['container', 'name', 'value']:
                            raise ValueError(
                                'Incorrect key found in environment variable update parameter: ' + key)
                except ValueError as value_error:
                    raise value_error
                except:
                    raise Exception(
                        'Environment variable update parameter could not be processed; please check parameter value: ' + container_env_var_updates)
            
                # Expected format: container=...,image-and-tag|image|tag=...,container=...,image-and-tag|image|tag=...,
                try:
                    image_kv_pairs = container_image_name_updates.split(',')
                    for index, kv_pair in enumerate(image_kv_pairs):
                        kv = kv_pair.split('=')
                        key = kv[0].strip()
                        if key == 'container':
                            container_name = kv[1].strip()
                            image_kv = image_kv_pairs[index+1].split('=')
                            container_entry = container_map.get(container_name)
                            if container_entry is None:
                                raise ValueError('The container ' + container_name +
                                                 ' is not defined in the existing task definition')
                            container_index = container_entry['index']
                            image_specifier_type = image_kv[0].strip()
                            image_value = image_kv[1].strip()
                            if image_specifier_type == 'image-and-tag':
                                container_definitions[container_index]['image'] = image_value
                            else:
                                existing_image_name_tokens = container_entry['image'].split(
                                    ':')
                                if image_specifier_type == 'image':
                                    tag = ''
                                    if len(existing_image_name_tokens) == 2:
                                        tag = ':' + existing_image_name_tokens[1]
                                    container_definitions[container_index]['image'] = image_value + tag
                                elif image_specifier_type == 'tag':
                                    container_definitions[container_index]['image'] = existing_image_name_tokens[0] + \
                                        ':' + image_value
                                else:
                                    raise ValueError(
                                        'Image name update parameter format is incorrect: ' + container_image_name_updates)
                        elif key and key not in ['container', 'image', 'image-and-tag', 'tag']:
                            raise ValueError(
                                'Incorrect key found in image name update parameter: ' + key)
            
                except ValueError as value_error:
                    raise value_error
                except:
                    raise Exception(
                        'Image name update parameter could not be processed; please check parameter value: ' + container_image_name_updates)
                return json.dumps(container_definitions)
            
            
            if __name__ == '__main__':
                try:
                    print(run(sys.argv[1], sys.argv[2], sys.argv[3]))
                except Exception as e:
                    sys.stderr.write(str(e) + "\n")
                    exit(1)

            EOF

            # Prepare container definitions
            CONTAINER_DEFS=$(python $UPDATE_CONTAINER_DEFS_SCRIPT_FILE "$PREVIOUS_TASK_DEFINITION" "$CONTAINER_IMAGE_NAME_UPDATES" "$CONTAINER_ENV_VAR_UPDATES")
            
            # Prepare script for getting task definition values
            GET_TASK_DFN_VAL_SCRIPT_FILE=$(mktemp _get_task_def_value.py.XXXXXX)
            cat > $GET_TASK_DFN_VAL_SCRIPT_FILE \<<-EOF
            import sys
            import json
            
            
            def run(element_name, task_definition_str):
                try:
                    definition = json.loads(task_definition_str)
                    task_definition = definition['taskDefinition']
                except:
                    raise Exception('No valid task definition found: ' +
                                    task_definition_str)
                str_list_types = ['requiresCompatibilities']
                json_arr_types = ['placementConstraints', 'volumes']
                if element_name in json_arr_types:
                    output_value = '[]'
                else:
                    output_value = ''
                if element_name in task_definition:
                    element_value = task_definition[element_name]
                    if element_name in str_list_types:
                        for i, list_item in enumerate(element_value):
                            output_value += list_item.strip()
                            if len(element_value) - 1 > i:
                                output_value += ' '
                    elif element_name in json_arr_types:
                        output_value = json.dumps(element_value)
                    else:
                        output_value = str(element_value)
                return output_value
            
            
            if __name__ == '__main__':
                try:
                    print(run(sys.argv[1], sys.argv[2]))
                except Exception as e:
                    sys.stderr.write(str(e) + "\n")
                    exit(1)

            EOF

            # Get other task definition values
            TASK_ROLE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'taskRoleArn' "$PREVIOUS_TASK_DEFINITION")
            EXECUTION_ROLE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'executionRoleArn' "$PREVIOUS_TASK_DEFINITION")
            NETWORK_MODE=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'networkMode' "$PREVIOUS_TASK_DEFINITION")
            VOLUMES=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'volumes' "$PREVIOUS_TASK_DEFINITION")
            PLACEMENT_CONSTRAINTS=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'placementConstraints' "$PREVIOUS_TASK_DEFINITION")
            REQ_COMP=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'requiresCompatibilities' "$PREVIOUS_TASK_DEFINITION")
            TASK_CPU=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'cpu' "$PREVIOUS_TASK_DEFINITION")
            TASK_MEMORY=$(python $GET_TASK_DFN_VAL_SCRIPT_FILE 'memory' "$PREVIOUS_TASK_DEFINITION")

            # Make task definition values available as env variables
            echo "export CCI_ORB_AWS_ECS_TASK_ROLE='${TASK_ROLE}'" >> $BASH_ENV
            echo "export CCI_ORB_AWS_ECS_EXECUTION_ROLE='${EXECUTION_ROLE}'" >> $BASH_ENV
            echo "export CCI_ORB_AWS_ECS_NETWORK_MODE='${NETWORK_MODE}'" >> $BASH_ENV
            echo "export CCI_ORB_AWS_ECS_CONTAINER_DEFS='${CONTAINER_DEFS}'" >> $BASH_ENV
            echo "export CCI_ORB_AWS_ECS_VOLUMES='${VOLUMES}'" >> $BASH_ENV
            echo "export CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS='${PLACEMENT_CONSTRAINTS}'" >> $BASH_ENV
            echo "export CCI_ORB_AWS_ECS_REQ_COMP='${REQ_COMP}'" >> $BASH_ENV
            echo "export CCI_ORB_AWS_ECS_TASK_CPU='${TASK_CPU}'" >> $BASH_ENV
            echo "export CCI_ORB_AWS_ECS_TASK_MEMORY='${TASK_MEMORY}'" >> $BASH_ENV

            rm $UPDATE_CONTAINER_DEFS_SCRIPT_FILE $GET_TASK_DFN_VAL_SCRIPT_FILE
      - run:
          name: Register task definition
          command: |
            <<# parameters.enable-trace >> set -x <</ parameters.enable-trace >>
            task_definition_args=()

            if [ -n "${CCI_ORB_AWS_ECS_TASK_ROLE}" ]; then
                task_definition_args+=(--task-role-arn "${CCI_ORB_AWS_ECS_TASK_ROLE}")
            fi
            if [ -n "${CCI_ORB_AWS_ECS_EXECUTION_ROLE}" ]; then
                task_definition_args+=(--execution-role-arn "${CCI_ORB_AWS_ECS_EXECUTION_ROLE}")
            fi
            if [ -n "${CCI_ORB_AWS_ECS_NETWORK_MODE}" ]; then
                task_definition_args+=(--network-mode "${CCI_ORB_AWS_ECS_NETWORK_MODE}")
            fi
            if [ -n "${CCI_ORB_AWS_ECS_VOLUMES}" ] && [ "${CCI_ORB_AWS_ECS_VOLUMES}" != "[]" ]; then
                task_definition_args+=(--volumes "${CCI_ORB_AWS_ECS_VOLUMES}")
            fi
            if [ -n "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}" ] && [ "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}" != "[]" ]; then
                task_definition_args+=(--placement-constraints "${CCI_ORB_AWS_ECS_PLACEMENT_CONSTRAINTS}")
            fi
            if [ -n "${CCI_ORB_AWS_ECS_REQ_COMP}" ] && [ "${CCI_ORB_AWS_ECS_REQ_COMP}" != "[]" ]; then
                task_definition_args+=(--requires-compatibilities ${CCI_ORB_AWS_ECS_REQ_COMP})
            fi
            if [ -n "${CCI_ORB_AWS_ECS_TASK_CPU}" ]; then
                task_definition_args+=(--cpu "${CCI_ORB_AWS_ECS_TASK_CPU}")
            fi
            if [ -n "${CCI_ORB_AWS_ECS_TASK_MEMORY}" ]; then
                task_definition_args+=(--memory "${CCI_ORB_AWS_ECS_TASK_MEMORY}")
            fi

            REVISION=$(aws ecs register-task-definition \
                --family << parameters.family >> \
                --container-definitions "${CCI_ORB_AWS_ECS_CONTAINER_DEFS}" \
                "${task_definition_args[@]}" \
                --output text \
                --query 'taskDefinition.taskDefinitionArn')
            echo "export CCI_ORB_AWS_ECS_REGISTERED_TASK_DFN='${REVISION}'" >> $BASH_ENV
      - run:
          name: Update service
          command: |
            <<# parameters.enable-trace >> set -x <</ parameters.enable-trace >>
            DEPLOYED_REVISION=$(aws ecs update-service \
                --cluster "<< parameters.cluster-name >>" \
                --service "<< parameters.family >>" \
                --task-definition "${CCI_ORB_AWS_ECS_REGISTERED_TASK_DFN}" \
                --output text \
                --query service.taskDefinition)
            echo "export CCI_ORB_AWS_ECS_DEPLOYED_REVISION='${DEPLOYED_REVISION}'" >> $BASH_ENV
      - when:
          condition: << parameters.verify-revision-deployment-stable >>
          steps:
            - wait-for-deployment-stability:
                family: << parameters.family >>
                cluster-name: << parameters.cluster-name >>
                task-definition-arn: "$CCI_ORB_AWS_ECS_DEPLOYED_REVISION"
                enable-trace: << parameters.enable-trace >>
